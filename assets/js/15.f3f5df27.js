(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{373:function(a,e,t){"use strict";t.r(e);var n=t(45),l=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[a._v("#")]),a._v(" Symbol")]),a._v(" "),t("p",[a._v("Symbol的出现是为了解决对象中属性命名的重复，Symbol保证了属性名称的唯一性。")]),a._v(" "),t("p",[a._v("Symbol也成为了JavaScript的第七种数据类型。")]),a._v(" "),t("p",[a._v("这样，对象的属性名可以有两种数据类型Symbol和字符串。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let s = Symbol();\ntypeof s // 'symbol'\n\n// s是独一无二的\n")])])]),t("p",[a._v("注意：Symbol不是对象，声明时不能用new，它是一种类似于字符串的类型。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let a = Symbol('foo');\nlet b = Symbol('bar');\n\n// 上面两个变量均为Symbol类型，如果不加上参数，在控制台打出的都是Symbol(),无法区分，所以加上变量即可区分\n")])])]),t("p",[a._v("注：参数只是为了区分Symbol，如果同一个参数，他们的值是不同的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// Symbol不能与其他类型运算，但可以显示转化为字符串。\n\nlet a = Symbol('foo');\na.toString();// \"Symbol(foo)\"\n\n// Symbol也可以转为布尔值，但不能转化为数值\n\n!a // false\na + 2; // TypeError\n")])])]),t("h2",{attrs:{id:"作为属性名的symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作为属性名的symbol"}},[a._v("#")]),a._v(" 作为属性名的Symbol")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// Symbol类型的值都是唯一的，所以可以避免对象中属性重复的问题。\n\n// 对象中增加Symbol类型的方式\n// 第一种\nlet a = {};\nlet mySymbol = Symbol();\na[mySymbol] = 'Hello';\n\n// 第二种\nlet a = {\n    [mySymbol]: 'Hello'\n}\n\n// 第三种\nlet a = {};\nObject.defineProperty(a, mySymbol, {\n    value: 'Hello'\n})\n")])])]),t("p",[a._v("注：")]),a._v(" "),t("ol",[t("li",[a._v("Symbol无法使用点运算符调用（因为点运算符后总跟着字符串）。")]),a._v(" "),t("li",[a._v("在对象中，Symbol类型必须使用[]定义。")]),a._v(" "),t("li",[a._v("Symbol类型作属性名时还是公开属性，并非私有属性。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 常见用法：定义常量\nconst COLOR_RED    = Symbol();\nconst COLOR_GREEN  = Symbol();\n\nfunction getComplement(color) {\n  switch (color) {\n    case COLOR_RED:\n      return COLOR_GREEN;\n    case COLOR_GREEN:\n      return COLOR_RED;\n    default:\n      throw new Error('Undefined color');\n    }\n}\n\nconsole.log(getComplement(COLOR_RED)); // Symbol()\nconsole.log(getComplement(COLOR_YELLOW)); // error\n")])])]),t("p",[a._v("注：Symbol与switch可以很好的搭配，在常量中属性的值是什么往往并不重要，只要保证属性名不同即可，所以Symbol很好的解决了这个问题")]),a._v(" "),t("p",[a._v("最常见的场景：消除魔法字符串。")]),a._v(" "),t("p",[a._v("魔法字符串：在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function getArea(shape, options) {\n  var area = 0;\n\n  switch (shape) {\n    case 'Triangle': // 魔术字符串\n      area = .5 * options.width * options.height;\n      break;\n    /* ... more code ... */\n  }\n\n  return area;\n}\n\ngetArea('Triangle', { width: 100, height: 100 });\n\n// 上面代码中 \"Triangle\"即为魔法字符串，改为下面优化代码。\nconst shapeType = {\n    triangle:Symbol()\n}\nfunction getArea(shape, options) {\n  var area = 0;\n\n  switch (shape) {\n    case shape.triangle: // 魔术字符串\n      area = .5 * options.width * options.height;\n      break;\n    /* ... more code ... */\n  }\n\n  return area;\n}\n\ngetArea(shape.triangle, { width: 100, height: 100 });\n")])])]),t("h2",{attrs:{id:"属性名的遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性名的遍历"}},[a._v("#")]),a._v(" 属性名的遍历")]),a._v(" "),t("p",[a._v("平时使用的遍历方法，如：Object.Keys(),for...of,for...in等，都不能将Symbol类型的值遍历出来。")]),a._v(" "),t("ol",[t("li",[a._v("使用 ==Object.getOwnPropertySymbols(obj)== 获取")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let mySymbol = Symbol('foo');\nlet a = {\n    [mySymbol]:'hello'\n}\nObject.getOwnPropertySymbols(a); // [Symbol(foo)]\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("使用==Reflect.ownKeys(obj)==获取")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let mySymbol = Symbol('foo');\nlet a = {\n    [mySymbol]:'hello'\n    mySymbol:'hello'\n}\nReflect.ownKeys(a); // ['mySymbol',Symbol(foo)]\n")])])]),t("p",[a._v("注：我们可以借助Symbol类型无法使用常见方法遍历的特性，造成一种非私有的内部方法的效果")]),a._v(" "),t("h2",{attrs:{id:"symbol-for-symbol-keyfor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol-for-symbol-keyfor"}},[a._v("#")]),a._v(" Symbol.for(),Symbol.keyFor()")]),a._v(" "),t("ol",[t("li",[a._v("Symbol.for()\n这个方法先搜索可以搜索到的Symbol变量，比较定义时传入的参数，如果参数一致，则把之前的值赋给它，如果没搜索到，则可以新定义一个Symbol类型的变量。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let a = Symbol.for('foo');\nlet b = Symbol.for('foo');\n\na === b; //true\n\n// 使用Symbol.for()创建的变量会被登记在当前作用于下供搜索\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("Symbol.keyFor()\nSymbol.keyFor方法返回一个已登记的 Symbol 类型值的key。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let a = Symbol.for('foo');\nSymbol.keyFor(a); // \"foo\"\n\nlet b = Symbol('bar');\nSymbol.keyFor(b); // undefined\n")])])]),t("h2",{attrs:{id:"内置的symbol值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置的symbol值"}},[a._v("#")]),a._v(" 内置的Symbol值")]),a._v(" "),t("ol",[t("li",[a._v("Symbol.hasInstance")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 当使用instanceof时会调用对象内部的Symbol.hasInstance方法\n\nlet b = {\n    [Symbol.hasInstance](obj) {\n        return obj instanceof Array\n    }\n}\n\nconsole.log([] instanceof b); // true\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("Symbol.isConcatSpreadable")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 数组默认可以展开，伪数组默认无法展开\nlet a = ['a','b'];\n['c'].concat(a,'d');// ['c','a','b','d']\n\nlet b = ['e','f'];\nb[Symbol.isConcatSpreadable] = false;\n['c'].concat(b, 'd');// ['c',['e','f'],'d']\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[a._v("Symbol.species")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class arr extends Array{\n    constructor(){\n        super();\n    }\n    static get [Symbol.species](){\n        return Array;\n    }\n}\n\nvar a = new arr(1,2,3);\nvar mapped = a.map(x => x * x);\nconsole.log(mapped instanceof arr); // false\nconsole.log(mapped instanceof Array); // true\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[a._v("Symbol.interator")])]),a._v(" "),t("p",[a._v("对象的Symbol.iterator属性，指向该对象的默认遍历器方法。")]),a._v(" "),t("p",[a._v("对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器")])])}),[],!1,null,null,null);e.default=l.exports}}]);
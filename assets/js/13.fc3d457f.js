(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{369:function(n,r,t){"use strict";t.r(r);var e=t(45),a=Object(e.a)({},(function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"不稳定排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不稳定排序"}},[n._v("#")]),n._v(" 不稳定排序")]),n._v(" "),t("h2",{attrs:{id:"选择排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[n._v("#")]),n._v(" 选择排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 直接选择排序\n * 从无序的数组中取出最小的数与第一个元素交换\n * 不稳定排序\n * 输入[5,8,6,2,3,1,4,7]\n * 输出[1,2,3,4,5,6,7,8]\n * 时间复杂度O(n2)\n * 平均空间复杂度O\n */\n\nfunction selectionSort(arr) {\n  let j = 0;\n  while (j < arr.length) {\n    let min = arr[j]\n    let index = j\n    for (let i = j + 1; i < arr.length; i++) {\n      if (arr[i] < min) {\n        min = arr[i]\n        index = i\n      }\n    }\n    [arr[j], arr[index]] = [arr[index], arr[j]]\n    j++\n  }\n}\n\nlet arr2 = [5, 8, 6, 2, 3, 1, 4, 7]\nselectionSort(arr2)\nconsole.log(arr2)\n")])])]),t("h2",{attrs:{id:"快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[n._v("#")]),n._v(" 快速排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 快速排序\n * 选择其中一个元素作为基数，并从两侧向里遍历，大于元素则放在元素右侧，反之放到左侧，并递归直至长度为1\n * 不稳定排序\n * 输入[5,8,6,2,3,1,4,7]\n * 输出[1,2,3,4,5,6,7,8]\n * 时间复杂度O(nlogn)\n */\n\nfunction quickSort(arr) {\n  sort(arr, 0, arr.length - 1)\n}\n\nfunction sort(arr, left, right) {\n  let baseNum = arr[left] // 基数\n  let leftIndex = left // 左指针\n  let rightIndex = right // 右指针\n  if (left < right) {\n    while (leftIndex !== rightIndex) {\n      while (leftIndex < rightIndex && arr[rightIndex] > baseNum) {\n        rightIndex--\n      }\n      arr[leftIndex] = arr[rightIndex]\n      while (leftIndex < rightIndex && arr[leftIndex] < baseNum) {\n        leftIndex++\n      }\n      arr[rightIndex] = arr[leftIndex]\n    }\n    arr[leftIndex] = baseNum\n    sort(arr, left, leftIndex - 1)\n    sort(arr, leftIndex + 1, right)\n  }\n}\n\nlet arr2 = [5, 8, 6, 2, 3, 1, 4, 7]\nquickSort(arr2)\nconsole.log(arr2)\n")])])]),t("h2",{attrs:{id:"希尔排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序"}},[n._v("#")]),n._v(" 希尔排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 希尔排序\n * 从大间隔向小间隔逐次遍历\n * 不稳定排序\n * 输入[5,8,6,2,3,1,4,7]\n * 输出[1,2,3,4,5,6,7,8]\n * 时间复杂度（nlog2n）\n */\n\n// 第一遍：gap = 4 ; 3,1,4,2,5,8,6,7\n// 第二遍：gap = 2 ; 3,1,4,2,5,8,6,7\n// 第三遍: gap = 1 ; 1,2,3,4,5,6,7,8\n\nfunction shellSort(arr) {\n  // 第一步找间隔\n  let gap = parseInt(arr.length / 2)\n  // 选定gap\n  for (gap; gap > 0; gap = parseInt(gap / 2)) {\n    // 从gap个元素开始比较\n    for (let i = gap; i < arr.length; i++) {\n      let j = i\n      let current = arr[i]\n      while (j - gap >= 0 && arr[j - gap] > current) {\n        arr[j] = arr[j-gap]\n        j = j - gap \n      }\n      arr[j] = current\n    }\n  }\n}\n\nlet arr2 = [5, 8, 6, 2, 3, 1, 4, 7]\nshellSort(arr2)\nconsole.log(arr2)\n")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);
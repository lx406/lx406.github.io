(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{374:function(a,t,e){"use strict";e.r(t);var n=e(45),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"变量的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量的解构赋值"}},[a._v("#")]),a._v(" 变量的解构赋值")]),a._v(" "),e("p",[a._v("解构赋值的规则：只要等号右边的值不是对象或者数组，就先将其转化为对象。由于undefined和null不能转化为对象，所以对它们进行解构赋值，都会报错。")]),a._v(" "),e("h3",{attrs:{id:"数组的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组的解构赋值"}},[a._v("#")]),a._v(" 数组的解构赋值")]),a._v(" "),e("ol",[e("li",[a._v("模式匹配：只要等号两边的模式相同，左边就会被赋予对应的值。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//es5\nlet a = 1;\nlet b = 2;\nlet c = 3;\n\n// es6\nlet [a,b,c] = [1,2,3];\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [head, ...tail] = [1,2,3,4];\nhead // 1\ntail // [2,3,4]\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [x,y,...z] = ['a'];\nx // 'a'\ny // undefined(如果结构不成功，变量的值为undefined)\nz // []\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 不完全解构\nlet [a,b] = [1,2,3];\na // 1\nb // 2\n// 不完全解构也能成功\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 如果右侧不是数组,都会报错，其实这里说是数组不够准确，应该是没有interator接口的结构\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n// 这里先简单介绍下，支持interator接口的结构：数组、类数组对象、Set和Map\nlet [a,b,c] = new Set([1,2,3]);\na // 1\nb // 2\nc // 3\n// 只要是具有interator接口，都可以采取数组形式解构赋值\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[a._v("默认值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let [a = 1] = [2];\na // 2\nlet [a = 1] = [undefined];\na // 1\nlet [a = 1] = [null];\na // null\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 如果默认值为函数，则函数是惰性执行的，即如果取默认值才会执行\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\n\n// 等价于\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n")])])]),e("h3",{attrs:{id:"对象的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的解构赋值"}},[a._v("#")]),a._v(" 对象的解构赋值")]),a._v(" "),e("ol",[e("li",[a._v("对象解构与数组解构的不同")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 数组内部是有顺序的，所以是按照位置解构的；而对象内没有顺序，所以要对应key来解构\nlet {foo, zoo} = {foo:1, zoo:2};\nfoo // 1\nzoo // 2\n\n// 其实上面的代码为下面代码的简写,\nlet {foo:foo, zoo:zoo} = {foo:1, zoo:2};\n\n// 所以说真正赋值的是冒号右侧变量\nlet {foo: baz} = {foo:1, zoo:2};\nbaz // 1\nfoo // error\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[a._v("对象也可嵌套赋值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 这里loc和start均是模式，只有line是变量；模式即为等式左右两边用来对应的，而变量才是真正定义赋值的\nvar node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nvar { loc: { start: { line }} } = node;\nline // 1\nloc  // error: loc is undefined\nstart // error: start is undefined\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[a._v("对象解构也可定义默认值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 和数组一样，只有赋的值 === undefined，才取默认值\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[a._v("对象解构的巧用")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 将现有对象方法，赋值到某个变量上\nlet {log, sin, cos} = Math;\n")])])]),e("h3",{attrs:{id:"字符串的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串的解构赋值"}},[a._v("#")]),a._v(" 字符串的解构赋值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 字符串被转换成了一个类似数组的对象\nlet [a,b,c,d,e] = 'hello'\na // 'h'\nb // 'e'\n\n// 类似数组的对象中有length属性，所以还可以按照对象解构，定义len\nlet {length: len} = 'hello';\nlen // 5\n")])])]),e("h3",{attrs:{id:"数值与布尔的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数值与布尔的解构赋值"}},[a._v("#")]),a._v(" 数值与布尔的解构赋值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n")])])]),e("h3",{attrs:{id:"函数参数的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数参数的解构赋值"}},[a._v("#")]),a._v(" 函数参数的解构赋值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n")])])]),e("h3",{attrs:{id:"圆括号问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#圆括号问题"}},[a._v("#")]),a._v(" 圆括号问题")]),a._v(" "),e("p",[a._v("解构时，一定不要在模式上加();")]),a._v(" "),e("h3",{attrs:{id:"解构的用途"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解构的用途"}},[a._v("#")]),a._v(" 解构的用途")]),a._v(" "),e("ol",[e("li",[a._v("交换变量的值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let x = 1;\nlet y = 2;\n[x, y] = [y, x];\nx // 2;\ny // 1;\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[a._v("从函数返回多个值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let a = function(){\n    return [1,2,3];\n}\nlet [b,c,d] = a();\n\nlet fn = function(){\n    return {\n        foo: 'foo',\n        zoo: 'zoo'\n    }\n}\nlet {foo, zoo} = fn();\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[a._v("函数参数的定义")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[a._v("提取JSON数据")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('let jsonData = {\n  id: 42,\n  status: "OK",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, "OK", [867, 5309]\n')])])]),e("ol",{attrs:{start:"5"}},[e("li",[a._v("函数参数的默认值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let a = function(b=2){}\n// 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n")])])]),e("ol",{attrs:{start:"6"}},[e("li",[a._v("遍历Map解构")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 因为Map提供了interator接口，所以可以使用for...of循环遍历，并且使用解构赋值。这样Map遍历就会变的非常简便\nlet a = new Map();\na.set('first', 'hello');\na.set('second','world');\n\nfor(let [key, value] of a){\n    console.log(`${key} is ${value}`)\n}\n// 还可以单独取key或者value\n\nfor(let [key] of a){}\nfor(let [,value] of a){}\n")])])]),e("ol",{attrs:{start:"7"}},[e("li",[a._v("输入模块的指定方法")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('// 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\nconst { SourceMapConsumer, SourceNode } = require("source-map");\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);
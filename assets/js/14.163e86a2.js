(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{372:function(t,p,a){"use strict";a.r(p);var c=a(45),h=Object(c.a)({},(function(){var t=this,p=t.$createElement,a=t._self._c||p;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),a("p",[t._v("http一开始被单纯的用来传输超文本文件，而http传输是基于tcp协议的，传输前需建立tcp链接，启动时需进行浏览器与服务器的三次握手，确定连接后，进行传输。")]),t._v(" "),a("p",[t._v("http1此时只支持一条tcp链接，而且都是短连接，不同的链接需要反复建立tcp链接，造成多次握手资源浪费，所以http1.1增加了keep-alive特性，不再反复建立tcp链接，减少资源消耗，并且http1.1支持一个域名建立最多6个tcp链接，减轻了单条连接时队头堵塞的现象。但在资源请求很多的情况下，还是会出现队头堵塞的现象，而且多条tcp链接都会慢启动，导致比如首页渲染慢等传输慢的问题")]),t._v(" "),a("p",[t._v("http2为了解决以上问题，将多条tcp链接合成了一条，并增加了多路复用技术，支持传输端同时传输多条请求，请求没有限制，此时解决了http传输层队头堵塞的问题，也解决了多条tcp链接慢启动的问题，但是由于还是基于tcp协议，所以并未解决tcp中数据包传输的队头问题")]),t._v(" "),a("p",[t._v("http3发现只有抛弃tcp，在udp协议的基础上进行开发，才能真正解决队头堵塞问题，所以创建了quic协议。不过由于中间固件老化问题，如路由器、交换机等升级都比软件慢，这些中间固件都是对tcp支持优化的好，所以较难普及quic协议。")]),t._v(" "),a("h2",{attrs:{id:"http的队头堵塞-数据包队头堵塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http的队头堵塞-数据包队头堵塞"}},[t._v("#")]),t._v(" http的队头堵塞&数据包队头堵塞")]),t._v(" "),a("h3",{attrs:{id:"http的队头堵塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http的队头堵塞"}},[t._v("#")]),t._v(" http的队头堵塞")]),t._v(" "),a("p",[t._v("一个tcp链接只支持一个请求的传输，如果前一个一直未返回，则后面的请求会一直等待。")]),t._v(" "),a("h3",{attrs:{id:"数据包队头堵塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据包队头堵塞"}},[t._v("#")]),t._v(" 数据包队头堵塞")]),t._v(" "),a("p",[t._v("在tcp传输中，传输的资源会被分成多个数据包，比如index.html文件分成了1、2、3、4、5数据包，2、3、4、5返回后，1丢失了，那么会一直堵塞到1返回后，此链接才能通畅")]),t._v(" "),a("h2",{attrs:{id:"tcp的慢启动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的慢启动"}},[t._v("#")]),t._v(" tcp的慢启动")]),t._v(" "),a("p",[t._v("tcp为了避免拥塞，防止因为请求过多导致部分包丢失，tcp采用了慢启动的方式进行传输。")]),t._v(" "),a("p",[t._v("一开始初始化一个报文段大小，然后以指数倍增加，直到拥塞窗口阈值，超过后采用拥塞避免算法。")])])}),[],!1,null,null,null);p.default=h.exports}}]);
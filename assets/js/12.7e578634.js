(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{375:function(n,r,t){"use strict";t.r(r);var e=t(45),a=Object(e.a)({},(function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"稳定排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#稳定排序"}},[n._v("#")]),n._v(" 稳定排序")]),n._v(" "),t("h2",{attrs:{id:"冒泡排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[n._v("#")]),n._v(" 冒泡排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 冒泡排序\n * 两两交换，直到遍历n遍\n * 输入[5,8,6,2,3,1,4,7]\n * 输出[1,2,3,4,5,6,7,8]\n * 稳定排序（相同的两个元素位置不变）\n * 时间复杂度O(n2)\n * 平均空间复杂度O(1)\n */\n\nfunction bubbleSort(arr) {\n  let j = 0;\n  while (j < arr.length) {\n    for (let i = 0; i < arr.length - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n      }\n    }\n    j++\n  }\n}\n\nlet arr1 = [5, 8, 6, 2, 3, 1, 4, 7];\nbubbleSort(arr1);\nconsole.log(arr1);\n")])])]),t("h2",{attrs:{id:"插入排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[n._v("#")]),n._v(" 插入排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 插入排序\n * 将数组分成有序和无序两部分，首先将左一当做有序，将无序的第一个元素向有序数组中插入，直到全部插入结束\n * 输入[5,8,6,2,3,1,4,7]\n * 输出[1,2,3,4,5,6,7,8]\n * 稳定排序（相同的两个元素位置不变）\n * 时间复杂度 O(n2)\n * 空间复杂度\n */\n\nfunction insertSort(arr) {\n  let i = 1;\n  while (i < arr.length) {\n    for (let j = i; j > 0; j--) {\n      if (arr[j] < arr[j - 1]) {\n        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]\n      } else {\n        break\n      }\n    }\n    i++\n  }\n}\n\nlet arr2 = [5, 8, 6, 2, 3, 1, 4, 7]\ninsertSort(arr2)\nconsole.log(arr2)\n")])])]),t("h2",{attrs:{id:"归并排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[n._v("#")]),n._v(" 归并排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 归并排序\n * 先将数组两两分组（sort）直到不能再分，通过递归的方式，将分好的组进行排序（merge）\n * 输入[5,8,6,2,3,1,4,7]\n * 输出[1,2,3,4,5,6,7,8]\n * 稳定排序（相同的两个元素位置不变）\n * 时间复杂度 O(nlogn)\n * 空间复杂度\n */\n\nfunction mergeSort(arr) {\n  let temp = []\n  sort(arr, 0, arr.length - 1, temp)\n}\n\nfunction sort(arr, left, right, temp) {\n  if (left < right) {\n    let mid = parseInt((left + right) / 2)\n    sort(arr, left, mid, temp)\n    sort(arr, mid + 1, right, temp)\n    merge(arr, left, mid, right, temp)\n  }\n}\n\nfunction merge(arr, left, mid, right, temp) {\n  let leftIndex = left\n  let rightIndex = mid + 1\n  let t = 0\n  while (leftIndex < mid + 1 && rightIndex <= right) {\n    if (arr[leftIndex] <= arr[rightIndex]) {\n      temp[t++] = arr[leftIndex]\n      leftIndex++\n    } else {\n      temp[t++] = arr[rightIndex]\n      rightIndex++\n    }\n  }\n  while (leftIndex <= mid) {\n    temp[t++] = arr[leftIndex]\n    leftIndex++\n  }\n  while (rightIndex <= right) {\n    temp[t++] = arr[rightIndex]\n    rightIndex++\n  }\n  t = 0;\n  //将temp中的元素全部拷贝到原数组中\n  while (left <= right) {\n    arr[left++] = temp[t++];\n  }\n}\n\nlet arr2 = [5, 8, 6, 2, 3, 1, 4, 7]\nmergeSort(arr2)\nconsole.log(arr2)\n")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);